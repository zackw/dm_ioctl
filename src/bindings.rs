// SPDX-License-Identifier: LGPL-2.0+ WITH Linux-syscall-note
//
// This file is a derived work of the Linux kernel and of rust-bindgen;
// we have applied the kernel's license, as it is the more restrictive
// of the two, and as documentation has been copied verbatim from there.

//!  The raw ioctl interface defined by <linux/dm-ioctl.h>.
//!
//! Originally generated by rust-bindgen 0.69.5 from the <linux/dm-ioctl.h>
//! shipped with Linux 6.6.62, which identifies itself as API version
//! "4.48.0-ioctl (2023-03-01)", and then manually cleaned up.

#![allow(dead_code)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(clippy::missing_safety_doc)]

use ::core::ffi::{c_char, c_int, c_uint, c_ulonglong};
use ::core::fmt;
use ::core::marker::PhantomData;
use ::core::slice;

#[cfg(test)]
#[path = "tests/bindings.rs"]
mod tests;

#[repr(C)]
#[derive(Default)]
pub struct FlexibleArrayMember<T>(PhantomData<T>, [T; 0]);
impl<T> FlexibleArrayMember<T> {
    #[inline]
    pub const fn new() -> Self {
        FlexibleArrayMember(PhantomData, [])
    }
    #[inline]
    pub fn as_ptr(&self) -> *const T {
        self as *const _ as *const T
    }
    #[inline]
    pub fn as_mut_ptr(&mut self) -> *mut T {
        self as *mut _ as *mut T
    }
    #[inline]
    pub unsafe fn as_slice(&self, len: usize) -> &[T] {
        slice::from_raw_parts(self.as_ptr(), len)
    }
    #[inline]
    pub unsafe fn as_mut_slice(&mut self, len: usize) -> &mut [T] {
        slice::from_raw_parts_mut(self.as_mut_ptr(), len)
    }
}
impl<T> fmt::Debug for FlexibleArrayMember<T> {
    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {
        fmt.write_str("FlexibleArrayMember")
    }
}

pub const DM_DIR: &[u8; 7] = b"mapper\0";
pub const DM_CONTROL_NODE: &[u8; 8] = b"control\0";

pub const DM_MAX_TYPE_NAME: u32 = 16;
pub const DM_NAME_LEN: usize = 128;
pub const DM_UUID_LEN: usize = 129;

pub const DM_NAME_LIST_FLAG_HAS_UUID: u32 = 1;
pub const DM_NAME_LIST_FLAG_DOESNT_HAVE_UUID: u32 = 2;

/// Major version of the dm ioctl interface as defined by this header.
/// Not necessarily equal to the version as implemented by the running kernel.
pub const DM_VERSION_MAJOR: u32 = 4;

/// Minor version of the dm ioctl interface as defined by this header.
/// Not necessarily equal to the version as implemented by the running kernel.
pub const DM_VERSION_MINOR: u32 = 48;

/// Patchlevel version of the dm ioctl interface as defined by this header.
/// Not necessarily equal to the version as implemented by the running kernel.
pub const DM_VERSION_PATCHLEVEL: u32 = 0;

/// Extra version information.
pub const DM_VERSION_EXTRA: &[u8; 20] = b"-ioctl (2023-03-01)\0";

// Status bits

/// ??? "In/Out"
pub const DM_READONLY_FLAG: u32 = 1;

/// ??? "In/Out"
pub const DM_SUSPEND_FLAG: u32 = 2;

/// ??? "In"
pub const DM_PERSISTENT_DEV_FLAG: u32 = 8;

/// In: Pass into ioctl STATUS command to get table information rather
/// than current status.
pub const DM_STATUS_TABLE_FLAG: u32 = 16;

/// Out: Whether an active table is present for this device
pub const DM_ACTIVE_PRESENT_FLAG: u32 = 32;

/// Out: Whether an inactive table is present for this device
pub const DM_INACTIVE_PRESENT_FLAG: u32 = 64;

/// Out: Indicates that the buffer passed in wasn't big enough for the results.
pub const DM_BUFFER_FULL_FLAG: u32 = 256;

/// In: No longer used, ignored.
pub const DM_SKIP_BDGET_FLAG: u32 = 512;

/// In: Set this to avoid attempting to freeze any filesystem when suspending.
pub const DM_SKIP_LOCKFS_FLAG: u32 = 1024;

/// In: Set this to suspend without flushing queued ios.
/// Also disables flushing uncommitted changes in the thin target before
/// generating statistics for DM_TABLE_STATUS and DM_DEV_WAIT.
pub const DM_NOFLUSH_FLAG: u32 = 2048;

/// In: If set, any table information returned will relate to the inactive
/// table instead of the live one.  Always check DM_INACTIVE_PRESENT_FLAG
/// is set before using the data returned.
pub const DM_QUERY_INACTIVE_TABLE_FLAG: u32 = 4096;

/// Out: If set, a uevent was generated for which the caller may need to wait.
pub const DM_UEVENT_GENERATED_FLAG: u32 = 8192;

/// In: If set, rename changes the uuid not the name.  Only permitted
/// if no uuid was previously supplied: an existing uuid cannot be changed.
pub const DM_UUID_FLAG: u32 = 16384;

/// In: If set, all buffers are wiped after use. Use when sending
/// or requesting sensitive data such as an encryption key.
pub const DM_SECURE_DATA_FLAG: u32 = 32768;

/// Out: If set, a message generated output data.
pub const DM_DATA_OUT_FLAG: u32 = 65536;

/// In/Out: If set with DM_DEV_REMOVE or DM_REMOVE_ALL this indicates that if
/// the device cannot be removed immediately because it is still in use
/// it should instead be scheduled for removal when it gets closed.
///
/// On return from DM_DEV_REMOVE, DM_DEV_STATUS or other ioctls, this
/// flag indicates that the device is scheduled to be removed when it
/// gets closed.
pub const DM_DEFERRED_REMOVE: u32 = 131072;

/// Out: If set, the device is suspended internally.
pub const DM_INTERNAL_SUSPEND_FLAG: u32 = 262144;

/// Out: If set, the device is suspended internally.
pub const DM_IMA_MEASUREMENT_FLAG: u32 = 524288;

/// `_IOC` type code for device mapper ioctls.
pub const DM_IOCTL: u32 = 0xFD;

/// `_IOC` operation codes for device mapper ioctls.
#[repr(u8)]
#[derive(Copy, Clone, Debug, Eq, PartialEq)]
pub enum DmIoctlCmd {
    /// Get the version information for the ioctl interface.
    DM_VERSION_CMD = 0,

    ///  Remove all dm devices, destroy all tables.  Only really used for debug.
    DM_REMOVE_ALL_CMD = 1,

    /// Get a list of all the dm device names.
    DM_LIST_DEVICES_CMD = 2,

    /// Create a new device, neither the 'active' or 'inactive' table
    /// slots will be filled.  The device will be in suspended state
    /// after creation, however any io to the device will get errored
    /// since it will be out-of-bounds.
    DM_DEV_CREATE_CMD = 3,

    /// Remove a device, destroy any tables.
    DM_DEV_REMOVE_CMD = 4,

    /// Rename a device or set its uuid if none was previously supplied.
    DM_DEV_RENAME_CMD = 5,

    /// This performs both suspend and resume, depending which flag is
    /// passed in.
    ///
    /// Suspend: This command will not return until all pending io to
    /// the device has completed.  Further io will be deferred until
    /// the device is resumed.
    ///
    /// Resume: It is no longer an error to issue this command on an
    /// unsuspended device.  If a table is present in the 'inactive'
    /// slot, it will be moved to the active slot, then the old table
    /// from the active slot will be _destroyed_.  Finally the device
    /// is resumed.
    DM_DEV_SUSPEND_CMD = 6,

    /// Retrieves the status for the table in the 'active' slot.
    DM_DEV_STATUS_CMD = 7,

    /// Wait for a significant event to occur to the device.  This
    /// could either be caused by an event triggered by one of the
    /// targets of the table in the 'active' slot, or a table change.
    DM_DEV_WAIT_CMD = 8,

    /// Load a table into the 'inactive' slot for the device.  The
    /// device does _not_ need to be suspended prior to this command.
    DM_TABLE_LOAD_CMD = 9,

    /// Destroy any table in the 'inactive' slot (ie. abort).
    DM_TABLE_CLEAR_CMD = 10,

    /// Return a set of device dependencies for the 'active' table.
    DM_TABLE_DEPS_CMD = 11,

    /// Return the targets status for the 'active' table.
    DM_TABLE_STATUS_CMD = 12,

    /// ???
    DM_LIST_VERSIONS_CMD = 13,

    /// Pass a message string to the target at a specific offset of a device.
    DM_TARGET_MSG_CMD = 14,

    /// Set the geometry of a device by passing in a string in this format:
    ///
    /// "cylinders heads sectors_per_track start_sector"
    ///
    /// Beware that CHS geometry is nearly obsolete and only provided
    /// for compatibility with dm devices that can be booted by a PC
    /// BIOS.  See struct hd_geometry for range limits.  Also note that
    /// the geometry is erased if the device size changes.
    DM_DEV_SET_GEOMETRY_CMD = 15,

    /// ???
    DM_DEV_ARM_POLL_CMD = 16,

    /// ???
    DM_GET_TARGET_VERSION_CMD = 17,
}

/// All ioctl arguments consist of a single chunk of memory,
/// with this structure at the start.  If a uuid is specified
/// any lookup (eg. for a DM_INFO) will be done on that, *not* the name.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dm_ioctl {
    /// The version number is made up of three parts:
    /// major - no backward or forward compatibility,
    /// minor - only backwards compatible,
    /// patch - both backwards and forwards compatible.
    ///
    /// All clients of the ioctl interface should fill in the
    /// version number of the interface that they were
    /// compiled with.
    ///
    /// All recognised ioctl commands (ie. those that don't
    /// return -ENOTTY) fill out this field, even if the
    /// command failed.
    pub version: [c_uint; 3usize],

    /// Total size of data passed in, including this struct.
    pub data_size: c_uint,

    /// Offset to start of the 'data' field, relative to the start of
    /// this struct.
    pub data_start: c_uint,

    /// ??? "in/out"
    pub target_count: c_uint,

    /// ??? "out"
    pub open_count: c_int,

    /// ??? "in/out"
    pub flags: c_uint,

    /// event_nr holds either the event number (input and output) or the
    /// uevent cookie value (input only).
    /// The DM_DEV_WAIT ioctl takes an event number as input.
    /// The DM_SUSPEND, DM_DEV_REMOVE and DM_DEV_RENAME ioctls
    /// use the field as a cookie to return in the DM_COOKIE
    /// variable with the uevents they issue.
    /// For output, the ioctls return the event number, not the cookie.
    pub event_nr: c_uint,

    /// Padding so that 'dev' is naturally aligned
    pub padding: c_uint,

    /// ??? "in/out"
    pub dev: c_ulonglong,

    /// Device name
    pub name: [c_char; DM_NAME_LEN],

    /// Unique identifier of the block device
    pub uuid: [c_char; DM_UUID_LEN],

    // ZW: FIXME: Should be FlexibleArrayMember<c_char> or even more precisely
    // union { data: FlexibleArrayMember<c_char>; pad: [c_char; 7] }
    // but then this struct could not be Copy.  If this is changed we
    // need to make sure that mem::size_of::<dm_ioctl>() still includes
    // these seven bytes so that _IOWR(DM_IOCTL, xxx, struct dm_ioctl)
    // values do not change.
    /// Padding or data
    pub data: [c_char; 7usize],
}

// ZW: Has to be impl'd by hand because there aren't built-in impls of
// Default for [c_char; 128] and [c_char; 129].  To be removed.
impl Default for dm_ioctl {
    fn default() -> Self {
        Self {
            version: [0, 0, 0],
            data_size: 0,
            data_start: 0,
            target_count: 0,
            open_count: 0,
            flags: 0,
            event_nr: 0,
            padding: 0,
            dev: 0,
            name: [0; DM_NAME_LEN],
            uuid: [0; DM_UUID_LEN],
            data: [0; 7],
        }
    }
}

/// Used to specify tables.  These structures appear after the dm_ioctl.
#[repr(C)]
#[derive(Debug, Default)]
pub struct dm_target_spec {
    /// ???
    pub sector_start: c_ulonglong,

    /// ???
    pub length: c_ulonglong,

    /// ??? "Used when reading from kernel only"
    pub status: c_int,

    /// Location of the next dm_target_spec.
    /// - When specifying targets on a DM_TABLE_LOAD command, this value is
    ///   the number of bytes from the start of the "current" dm_target_spec
    ///   to the start of the "next" dm_target_spec.
    /// - When retrieving targets on a DM_TABLE_STATUS command, this value
    ///   is the number of bytes from the start of the first dm_target_spec
    ///   (that follows the dm_ioctl struct) to the start of the "next"
    ///   dm_target_spec.
    pub next: c_uint,

    /// ???
    pub target_type: [c_char; 16usize],

    /// Parameter string starts immediately after this object.
    /// Be careful to add padding after string to ensure correct
    /// alignment of subsequent dm_target_spec.
    // note: not present in the kernel's struct definition
    pub params: FlexibleArrayMember<c_char>,
}

/// Used to retrieve the target dependencies.
#[repr(C)]
#[derive(Debug, Default)]
pub struct dm_target_deps {
    /// Array size
    pub count: c_uint,

    /// Padding so that 'dev' is naturally aligned; ignored
    pub padding: c_uint,

    /// ??? "out"
    pub dev: FlexibleArrayMember<c_ulonglong>,
}

/// Used to get a list of all dm devices.
#[repr(C)]
#[derive(Debug, Default)]
pub struct dm_name_list {
    /// ???
    pub dev: c_ulonglong,

    /// Offset to the next record from the _start_ of this one
    pub next: c_uint,

    /// ???
    pub name: FlexibleArrayMember<c_char>,
    /* The following members can be accessed by taking a pointer that
       points immediately after the terminating zero character in "name"
       and aligning this pointer to next 8-byte boundary.
       Uuid is present if the flag DM_NAME_LIST_FLAG_HAS_UUID is set.

       __u32 event_nr;
       __u32 flags;
       char uuid[0];

       [ZW: Flexible array member in the *middle* of a struct? Dude. WTF.]
    */
}

/// Used to retrieve the target versions
#[repr(C)]
#[derive(Debug, Default)]
pub struct dm_target_versions {
    /// ???
    pub next: c_uint,

    /// ???
    pub version: [c_uint; 3usize],

    /// ???
    pub name: FlexibleArrayMember<c_char>,
}

/// Used to pass message to a target
#[repr(C)]
#[derive(Debug, Default)]
pub struct dm_target_msg {
    /// ??? "Device sector"
    pub sector: c_ulonglong,

    /// ???
    pub message: FlexibleArrayMember<c_char>,
}
